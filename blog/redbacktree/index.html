<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>RedBlackTree : An Intuitive Approach :: zarif98sjs — zarif98sjs</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="RedBlackTree : An Intuitive Approach  Monologue  I remember when the first time I studied Red Black Tree (RBT) , it was an enigma . A seemingly random rotations and colorings seems to somehow balance a Binary Search Tree (BST) . But I had no intuition for why these rotations and colorings seem to magically balance the BST . I used to read these horrible case works and my reaction everytime after it got balanced was -" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://zarif98sjs.github.io/blog/blog/redbacktree/" />




<link rel="stylesheet" href="https://zarif98sjs.github.io/blog/assets/style.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zarif98sjs.github.io/blog/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="https://zarif98sjs.github.io/blog/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />

  <meta name="twitter:site" content="" />

<meta name="twitter:creator" content="~25 min read" />


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="RedBlackTree : An Intuitive Approach :: zarif98sjs">
<meta property="og:description" content="Demystifying Red Black Trees!" />
<meta property="og:url" content="https://zarif98sjs.github.io/blog/blog/redbacktree/" />
<meta property="og:site_name" content="RedBlackTree : An Intuitive Approach" />

  <meta property="og:image" content="https://zarif98sjs.github.io/blog/img/RBTDrawings/Images/Title.png">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2020-10-19 00:00:00 &#43;0000 UTC" />












</head>
<body class="">


<div class="container full headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://zarif98sjs.github.io/">
  <div class="logo">
    zarif98sjs
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://zarif98sjs.github.io/about/">About</a></li>
        
      
        
          <li><a href="https://zarif98sjs.github.io/projects/">Projects</a></li>
        
      
        
          <li><a href="https://zarif98sjs.github.io/skills/">Skills</a></li>
        
      
        
          <li><a href="/blog/memento/">Memento</a></li>
        
      
        
          <li><a href="/blog/blog">Blog</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://zarif98sjs.github.io/about/">About</a></li>
      
    
      
        <li><a href="https://zarif98sjs.github.io/projects/">Projects</a></li>
      
    
      
        <li><a href="https://zarif98sjs.github.io/skills/">Skills</a></li>
      
    
      
        <li><a href="/blog/memento/">Memento</a></li>
      
    
      
        <li><a href="/blog/blog">Blog</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://zarif98sjs.github.io/blog/blog/redbacktree/">RedBlackTree : An Intuitive Approach</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2020-10-19
    </span>
    
    
    <span class="post-author">::
      ~25 min read
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://zarif98sjs.github.io/blog/tags/data-structure/">data structure</a>&nbsp;
    
    #<a href="https://zarif98sjs.github.io/blog/tags/binary-search-tree/">binary search tree</a>&nbsp;
    
    #<a href="https://zarif98sjs.github.io/blog/tags/balanced-binary-search-tree/">balanced binary search tree</a>&nbsp;
    
    #<a href="https://zarif98sjs.github.io/blog/tags/red-black-tree/">red black tree</a>&nbsp;
    
  </span>
  

  
  <img src="https://zarif98sjs.github.io/blog/img/RBTDrawings/Images/Title.png" class="post-cover" />
  

  <div class="post-content"><div>
        <h1 id="redblacktree--an-intuitive-approach"><strong>RedBlackTree : An Intuitive Approach</strong><a href="#redblacktree--an-intuitive-approach" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<h1 id="monologue"><strong>Monologue</strong><a href="#monologue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>I remember when the first time I studied <strong><code>Red Black Tree</code></strong> <strong>(RBT)</strong> , it was an enigma . A seemingly random <em>rotations</em> and <em>colorings</em> seems to somehow balance a <strong><code>Binary Search Tree</code></strong> <strong>(BST)</strong> . But I had no intuition for why these rotations and colorings seem to magically balance the BST . I used to read these horrible case works and my reaction everytime after it got balanced was -</p>

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/Pikachu.webp"  alt="Surprised Pikachu"   />
    
      <figcaption class="center"  style="color: #000000;" >Surprised Pikachu Face</figcaption>
    
  </figure>


<p> 
I had no idea what the <strong><code>RED</code></strong> and <strong><code>BLACK</code></strong> node represents . I didn&rsquo;t even understand why they exist in the first place . After all , what has coloring got to do with the balancing of a Binary Search Tree , right ? . And why are they even called Red and Black , why not any other colors (<em>the answer is hilarious XD</em>) . All in all , it was a giant <strong>black box</strong> . All these <code>Insert</code> and <code>Delete</code> cases , nothing properly made sense . The number of unanswered questions stacked up and up . So , I had to do something about it . After few weeks of <em>researching</em> (read <em><strong>googling</strong></em>) , scouring through the internet and with a bit of imagination , I think I finally got ahold of the answers to all the questions that my dumb brain was unable to grasp : ) . This writeup is to accumulate all these answers and make an intuitive approach to Red BLack Trees so that dumb people like me can also have a proper intuition for the underlying operations in Red Black Tree and so that you don&rsquo;t have to do all go through all of these by yourself again .</p>
<p> 
You might never need to understand the underlying intuitions behind all the operations . You can just call <strong>stl</strong> <strong><code>map</code></strong> or <strong><code>set</code></strong> in <code>c++</code> and <strong><code>TreeMap</code></strong> in <code>java</code> , and can easily pass your life in peace . But if you do care for the intuition , <em>you are in for a ride</em> : D</p>
<blockquote>
<h1 id="the-story-begins"><strong>The Story Begins</strong><a href="#the-story-begins" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>To properly understand anything one need to know its past . In my search for proper understanding of Red Black Trees , this is when it actually started to make sense to me for the first time .</p>
<p>I assume that you are familiar with Binary Search Trees and their shortcomings ( The complexity depends on tree height and in the worst case the height can be N , making most of the operations <strong><code>O(N)</code></strong> )</p>
<p>So , we need to somehow make it balanced such that on average the height is <strong><code>logN</code></strong> . Red Black Tree with it magic <code>rotations</code> and <code>colorings</code> seems to somehow do this . But this is not the only data structure to do this . <em>The key to understanding RBT lies on the first few variant of this data structure that attempted to solve this balance of BSTs</em>.</p>
<h2 id="a-slightly-modified-bst"><strong>A slightly modified BST</strong><a href="#a-slightly-modified-bst" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Let&rsquo;s consider a slight variant of the <strong>BST</strong>. Instead of <strong>1 key</strong> per node as in the regular BST , we will store upto <strong>2 keys</strong> per node in this case and each node can have <strong>upto 3 child</strong> .</p>

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModBST.png"  alt="Modified BST"   />
    
      <figcaption class="center"  style="color: #000000;" >Modified BST</figcaption>
    
  </figure>


<p>That&rsquo;s it ! No other difference .</p>
<p>Now first consider <strong>insertion</strong> in this tree . How will we insert a node ?<br>
 
The idea is almost identical to regular BST . We compare the key wih the one in the tree and decide to go left , right or <strong>middle</strong> . Yes , the middle part is the only new thing here . This addition of new option is not hard to see why , since there can be 2 keys per node , the number of paths to take will be 3 of course !<br>
 
Now , what happens when  we find the position for insertion key . If adding this key doesn&rsquo;t change the property that we assumed (atmost 2 keys per node) , we can just easily add it !</p>
<ul>
<li>
<p><strong>When can we just add it without any concern ?</strong><br>
If we find that there is only 1 key , then we can just add another key and our tree properties will be perfectly fine !</p>

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert1.png"  alt="Insert 11"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 11</figcaption>
    
  </figure>



  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert2.png"  alt="Insert 11"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 11</figcaption>
    
  </figure>


</li>
</ul>
<p> </p>
<ul>
<li>
<p><strong>When does problem arise ?</strong><br>
The problematic case : we find the corresponding place for insertion and we insert it . If after insertion we see there are 3 keys , we are in trouble : ( As mentioned earlier , there can be atmost 2 keys per node . So , we need to somehow fix this unstable node . Otherwise we are doomed . Here is an example .</p>

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert3.png"  alt="Insert 26"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 26</figcaption>
    
  </figure>



  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert4.png"  alt="Insert 26"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 26</figcaption>
    
  </figure>


</li>
</ul>
<p>Now that we are stuck , it&rsquo;s not hard no find a way around in this tree . We see that <code>18</code> is sitting lonely out there and has a place for one extra friend . We push up the middle key of the unstable node and voila we are good again . There are no more 3 key node in this tree . 

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert5.png"  alt="Insert 26"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 26</figcaption>
    
  </figure>


Nice save : D</p>
<p>Now if you have <em>good observation</em> , you might have observed that <em>all the leaf nodes have same distance from the root</em> . This is not just a coincidence . Let&rsquo;s see why this is the case .<br>
 
We have seen 2 different type of insertions so far and if you noticed , none of them changed the height of the tree . Now let&rsquo;s consider a case where the push up is such that there is an increase of height .</p>
<p><img src="Images/insert6.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert6.PNG"  alt="Insert 12"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 12</figcaption>
    
  </figure>

</p>
<p><img src="Images/insert7.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert7.PNG"  alt="Insert 12"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 12</figcaption>
    
  </figure>

</p>
<p><img src="Images/insert8.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert8.PNG"  alt="Insert 12"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 12</figcaption>
    
  </figure>

</p>
<p><img src="Images/insert9.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/ModInsert9.PNG"  alt="Insert 12"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 12</figcaption>
    
  </figure>

</p>
<p>Did you see what just happened ? The height of the tree increased by 1 and the distance of all the leaf nodes increased exactly by 1 . Thus leading to having all the leaf nodes in the same height/depth .</p>
<h3 id="key-takeaway-from-slightly-modified-bst"><strong>Key Takeaway from slightly modified BST</strong><a href="#key-takeaway-from-slightly-modified-bst" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>We saw earlier that if there was a way to balance our BST , we can efficiently do operations . Our slightly modified BST does exactly that ! We just saw that our tree is always perfectly balanced !
In this slightly modified BST ,</p>
<ul>
<li><strong>Worst Case Height</strong> : <strong><code>O(log_base2_N)</code></strong> / <strong><code>O(logN)</code></strong> (All nodes have 2 keys)</li>
<li><strong>Best Case Height</strong> : <strong><code>O(log_base3_N)</code></strong> (All nodes have 3 keys)</li>
</ul>
<h2 id="modifying-one-step-further"><strong>Modifying one step further</strong><a href="#modifying-one-step-further" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>This time we will allow upto 3 keys per node . One more than the last time . This time there is also one problematic case : when we  have 4 keys per node . We also do almost the same thing we did the last time . When there is a potential 4 key node , we split to make room for the new key .</p>
<p>I will just show an example and won&rsquo;t dive deep .</p>
<p><img src="RBTDrawings/Images/DoubleModInsert1.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/DoubleModInsert1.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/DoubleModInsert2.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/DoubleModInsert2.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/DoubleModInsert3.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/DoubleModInsert3.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/DoubleModInsert4.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/DoubleModInsert4.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p> </p>
<blockquote>
<h1 id="changing-vantage-point"><strong>Changing Vantage Point</strong><a href="#changing-vantage-point" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>Simulating this tree seems to be very easy in hand . But coding up this is not . Maintains variable number of keys in a node and also handling tree splitting can be a cumbersome job to do . If you are a lazy guy like me you wouldn&rsquo;t dare to implement this .</p>
<p> 
Now , let&rsquo;s change our vantage point . Let&rsquo;s cleverly represent this nodes so that we don&rsquo;t have to deal with all these tree splitting and variable nodes .</p>
<p> 
With a bit of imagination , we can think the 2 key nodes as 2 separate nodes glued together by an edge . If we draw this link by leaning on the side a bit , you can see that it is just your familiar BST .</p>
<p> 
But wait ! How do you distinguish between an <strong>ordinary edge</strong> and a <strong>glue edge</strong> . Yes ! we color it : D</p>
<p>Here&rsquo;s how we can represent the <strong><code>2 key nodes</code></strong> :</p>
<p><img src="RBTDrawings/Images/GlueEdge1.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/GlueEdge1.png"  alt="2 Key Node"   />
    
      <figcaption class="center"  style="color: #000000;" >2 Key Node</figcaption>
    
  </figure>

</p>
<p>And here&rsquo;s how we can represent the <strong><code>3 key nodes</code></strong> :</p>
<p><img src="RBTDrawings/Images/GlueEdge2.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/GlueEdge2.png"  alt="3 Key Node"   />
    
      <figcaption class="center"  style="color: #000000;" >3 Key Node</figcaption>
    
  </figure>

</p>
<p>We can also instead color children nodes thus making it convenient to implement as tracking edge colors in BST implementation would not be a headache anymore .</p>
<p><img src="RBTDrawings/Images/GlueEdge3.png" alt=""> 

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/GlueEdge3.png"  alt="Node Coloring"   />
    
      <figcaption class="center"  style="color: #000000;" >Node Coloring</figcaption>
    
  </figure>

</p>
<p>This was the eureka moment for me ! This is the <strong>Red Black Tree</strong> we have studied blindly all this time ! Finally we figured out the <strong><code>coloring</code></strong> ! RBT is nothing but a fancy way of representing the modified BSTs we saw earlier . Isn&rsquo;t this great ? : D</p>
<p><img src="RBTDrawings/Images/meme.jpg" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/meme.jpg"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >* insert a modified BST in place of the earth * Too lazy to do that :3</figcaption>
    
  </figure>

</p>
<p>Now you ask , why is this red ? Why not any other colors ?</p>
<!-- raw HTML omitted -->
<p>It was because the guys who invented this , only had red and black pens to draw :v And they chose to color the nodes red .</p>
<!-- raw HTML omitted -->
<p> </p>
<blockquote>
<h1 id="inside-the-black-box"><strong>Inside the Black Box</strong><a href="#inside-the-black-box" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<h2 id="insert"><strong>Insert</strong><a href="#insert" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now , we know that the operations we saw till now was RBT under the hood . Let&rsquo;s see how these operations look in the RBT .</p>
<p><img src="RBTDrawings/Images/RBTInsert1.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert1.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/RBTInsert2.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert2.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/RBTInsert4.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert4.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p>If you open a random book , you must have seen this weird rule which goes something like this : <em>when there are 2 red nodes in a row and uncle is also a red node , we do color flip</em> . <strong>Now you see what those color flip actually do !</strong> These is just <em>a fancy way to implement the splitting on the modified BST</em> .</p>
<p>Now , let&rsquo;s see another type of insertion .</p>
<p><img src="RBTDrawings/Images/RBTInsert5.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert5.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/RBTInsert6.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert6.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p><img src="RBTDrawings/Images/RBTInsert7.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/RBTInsert7.png"  alt="Insert 1"   />
    
      <figcaption class="center"  style="color: #000000;" >Insert 1</figcaption>
    
  </figure>

</p>
<p>You might have also seen a rule which goes something like this : _when there are 2 red nodes in a row and uncle is a black node , we need to rotate to balance the RBT _. This is just a normal insertion in the modified BST ! This one has 2 case : the node could be red nodes could be in Left Right order unlike the Left left order shown in the last example . This is the same , we just do 2 rotations to come to our proper 3 key node representation .</p>
<h2 id="delete"><strong>Delete</strong><a href="#delete" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Insertion was pretty easy . Most of the books represent delete in RBT as an awful hard operation . Infact when I first read the deletion , it was just a bunch of messy casework to memorize and I had no idea what the heck we were actually doing . But now , it has changed . Deletion is not difficult than insertion in any way , if not easier !</p>
<p> 
But , first let&rsquo;s recap some RBT properties which can be easily seen from our modified BST analogy :</p>
<ul>
<li>In modified BST , all leaf nodes were at the same height . So , in our RBT all the subtrees will have same black height (remember how red nodes doesn&rsquo;t contribute to the height , we just lean on either side to mimic BST)</li>
<li>Root is always black</li>
</ul>
<p>This 2 properties are enough to understand Deletion .</p>
<p>Deletion process is almost similar to the normal BST . I won&rsquo;t dive deep . Here is a recap :</p>
<ul>
<li>If we have less than 2 child , we can delete this node</li>
<li>Otherwise , we replace with the successor / predecessor node and delete that node instead</li>
</ul>
<p>Now in case of RBT , there can be some violation . Let&rsquo;s see :</p>
<ul>
<li>If we are deleting a red node , we are safe (Remember that we can easily delete from 2 key node in our slightly modified BST as it doesn&rsquo;t affect the height of the tree)</li>
<li>But if we are deleting a black node , we are in trouble : (  Deleting a black node will violate the first property we have seen earlier . We gotta fix this . This is the whole fiasco is about .</li>
</ul>
<p>Let&rsquo;s begin . Rather than telling you a bunch of awful rules to memorize , let us see what can and can&rsquo;t be done intuitively . Let me walk you thorough -</p>
<p><strong>The Easy One</strong></p>
<p> 
This time , the node we deleted has black sibling and no red children . Let see how it goes if we want to restore balance -</p>
<p><img src="RBTDrawings/Images/Delete1.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/Delete1.png"  alt="Black Sibling , No Red Children"   />
    
      <figcaption class="center"  style="color: #000000;" >Black Sibling , No Red Children</figcaption>
    
  </figure>

</p>
<p>The idea to solve this is we hand our problem to the parent . And if the parent couldn&rsquo;t solve , then we repeat the same process . We know that it will be fixed some time in the future because we just saw in the case of parent being the root , our problem is solved <strong>immediately</strong> .</p>
<p><img src="RBTDrawings/Images/Delete2.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/Delete2.PNG"  alt="Black Sibling , No Red Children"   />
    
      <figcaption class="center"  style="color: #000000;" >Black Sibling , No Red Children</figcaption>
    
  </figure>

</p>
<p><strong>The Easier One</strong></p>
<p> 
This time , the node we deleted has black sibling and at least one red children . Let&rsquo;s see how this one goes -</p>
<p><img src="RBTDrawings/Images/Delete3.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/Delete3.PNG"  alt="Black Sibling , Red Children"   />
    
      <figcaption class="center"  style="color: #000000;" >Black Sibling , Red Children</figcaption>
    
  </figure>

</p>
<p>Pretty easy !</p>
<p>There is just one corner case , if the only red child was the right node in the example we just saw , we would have to do one more rotation (like we did in the insert) to make it like the one we solved .</p>
<p><strong>The Clever One</strong></p>
<p>We are almost done . We just need to take care of one last thing . The red sibling case -</p>
<p><img src="RBTDrawings/Images/Delete4.png" alt="">

  <figure class="center" >
    <img src="/blog/img/RBTDrawings/Images/Delete4.PNG"  alt="Red Sibling"   />
    
      <figcaption class="center"  style="color: #000000;" >Red Sibling</figcaption>
    
  </figure>

</p>
<p>And now , we are done . See ! It was not that bad . Once we know why we are doing what , it immensely simplifies stuffs !</p>
<blockquote>
<h1 id="getting-our-hands-dirty-with-code"><strong>Getting our hands dirty (with code)</strong><a href="#getting-our-hands-dirty-with-code" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>All these efforts till now were all for this . We had to come up with glue nodes and colorings and what not just so that we can easily implement this thing . So , let&rsquo;s get into it !</p>
<p>I remember when i first the RBT pseudocode from Cormen (CLRS) , I had a mini heart attack . My first reaction was , &quot; Eww, how can a code be this ugly ! &quot; And the impression hasn&rsquo;t changed a bit . It is still one of the most ugliest implementation I&rsquo;ve seen till date . Coding a red black tree doesn&rsquo;t have to be this ugly .</p>
<p>Instead , I will guide you with a recursive implementation which I found much easier to code . Much much easier to debug and the size of the code will be half the size of the cormen implementation if not less .</p>
<h2 id="the-node"><strong>The Node</strong><a href="#the-node" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>We need just one more information from our usual BST : Color . No need to track parent or any other things . And about <em>why we have taken a pointer array</em> , not 2 <code>left</code> <code>right</code> pointers , I will get to that in a second .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">
<span style="color:#75715e">#define left 0
</span><span style="color:#75715e">#define right 1
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>
{
    <span style="color:#66d9ef">int</span> data,color;
    Node <span style="color:#f92672">*</span>child[<span style="color:#ae81ff">2</span>];

    Node(<span style="color:#66d9ef">int</span> data,<span style="color:#66d9ef">int</span> color)
    {
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> color;
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>child[left] <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>child[right] <span style="color:#f92672">=</span> NULL;
    }
};
</code></pre></div><h2 id="auxiliary-operations"><strong>Auxiliary Operations</strong><a href="#auxiliary-operations" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The main auxiliary operations are <strong><code>rotation</code></strong> and <strong><code>color flipping</code></strong> . The implementations are pretty much straightforward . If we had taken 2 separate pointers , the implementation would be like this</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">colorFlip</span>(Node <span style="color:#f92672">*</span>node)
{
    node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>color<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>;
    node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>color<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>;
    node<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>color<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>;
}

Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">leftRotate</span>(Node <span style="color:#f92672">*</span>node)
{
    Node <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
    node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>left;
    temp<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;

    temp<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>color;
    node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> RED;

    <span style="color:#66d9ef">return</span> temp;
}

Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">rightRotate</span>(Node <span style="color:#f92672">*</span>node)
{
    Node <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
    node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>right;
    temp<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;

    temp<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>color;
    node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> RED;

    <span style="color:#66d9ef">return</span> temp;
}
</code></pre></div><p>But , if instead we had implemented using <code>pointer array</code> , we can actually write only one function for the rotation !</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">rotate</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">bool</span> dir) <span style="color:#75715e">/// direction : left / right
</span><span style="color:#75715e"></span>{
    Node <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir];
    node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir] <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>child[dir];
    temp<span style="color:#f92672">-&gt;</span>child[dir] <span style="color:#f92672">=</span> node;

    temp<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>color;
    node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> RED;

    <span style="color:#66d9ef">return</span> temp;
}
</code></pre></div><p>And this way , our <code>double rotation</code> code is just 2 lines !</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">doubleRotate</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">bool</span> dir) <span style="color:#75715e">/// align reds  , then rotate
</span><span style="color:#75715e"></span>{
    node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir] <span style="color:#f92672">=</span> rotate(node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir],<span style="color:#f92672">!</span>dir);
    <span style="color:#66d9ef">return</span> rotate(node,dir);
}
</code></pre></div><p>We have already made our code half the size ! You will be amazed to see the magic of this further when we don&rsquo;t have to seperately handle the mirror cases in insert and delete operation : D At least I was , when I found out this trick when scouring through the internet which dramatically reduced my original insert implementation .</p>
<p>Let&rsquo;s get into insertion .</p>
<h2 id="insert-1"><strong>Insert</strong><a href="#insert-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> data)
{
    root <span style="color:#f92672">=</span> __insert(root,data);
    root<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK;
}

Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">__insert</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">int</span> data)
{
    <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">==</span> NULL)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Node(data,RED);

    <span style="color:#66d9ef">bool</span> dir <span style="color:#f92672">=</span> data <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>data; <span style="color:#75715e">/// left -&gt; 0 , right -&gt; 1
</span><span style="color:#75715e"></span>
    node<span style="color:#f92672">-&gt;</span>child[dir] <span style="color:#f92672">=</span> __insert(node<span style="color:#f92672">-&gt;</span>child[dir],data);

    <span style="color:#66d9ef">return</span> INSERT_FIX_UP(node,dir);
}
</code></pre></div><p>We just need to write this magic function <strong><code>INSERT_FIX_UP</code></strong> and we are done ! Iterative implementations needs to track parent and also handing all the cases can be really pain . But , we will take advantage of the bottom up approach . If a RBT property violation has occurred , we will fix on our way up in the recursion !</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">INSERT_FIX_UP</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">bool</span> dir)
{
    <span style="color:#66d9ef">if</span>(red(node<span style="color:#f92672">-&gt;</span>child[dir]))
    {
        <span style="color:#75715e">/// case 1 : both child red =&gt; any one child has 2 reds in a row (LL LR RR RL) =&gt; flip colors
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(red(node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir]))
        {
            <span style="color:#66d9ef">if</span>(red(node<span style="color:#f92672">-&gt;</span>child[dir]<span style="color:#f92672">-&gt;</span>child[dir]) <span style="color:#f92672">||</span> red(node<span style="color:#f92672">-&gt;</span>child[dir]<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir]))
            {
                colorFlip(node);
            }
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">/// case 2 : both child not red
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(red(node<span style="color:#f92672">-&gt;</span>child[dir]<span style="color:#f92672">-&gt;</span>child[dir]))
            {
                <span style="color:#75715e">/// any one child has 2 reds in a row (LL RR) =&gt; rotate
</span><span style="color:#75715e"></span>                node <span style="color:#f92672">=</span> rotate(node,<span style="color:#f92672">!</span>dir);
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(red(node<span style="color:#f92672">-&gt;</span>child[dir]<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir]))
            {
                <span style="color:#75715e">/// any one child has 2 reds in a row (LR RL) =&gt; align first , then rotate
</span><span style="color:#75715e"></span>                node <span style="color:#f92672">=</span> doubleRotate(node,<span style="color:#f92672">!</span>dir);
            }
        }
    }
    <span style="color:#66d9ef">return</span> node;
}
</code></pre></div><p>See , how we don&rsquo;t need to write code for additional <strong>mirror cases</strong> !</p>
<h2 id="delete-1"><strong>Delete</strong><a href="#delete-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The delete skeleton is the same as regular BST , with just one minor change . We keep a <strong><code>flag</code></strong> variable to keep track if we have already restored the balance or not .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_</span>(<span style="color:#66d9ef">int</span> data)
{
    <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> false;
    root <span style="color:#f92672">=</span> __delete(root,data,ok);
    <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">!=</span>NULL) root<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK;
}

Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">__delete</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">int</span> data,<span style="color:#66d9ef">bool</span> <span style="color:#f92672">&amp;</span>ok)
{
    <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">==</span> NULL)
    {
        ok <span style="color:#f92672">=</span> true;
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e">/// found the delete key
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> data)
    {
        <span style="color:#75715e">/// has one or less child
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>child[left]<span style="color:#f92672">==</span>NULL <span style="color:#f92672">||</span> node<span style="color:#f92672">-&gt;</span>child[right]<span style="color:#f92672">==</span>NULL)
        {
            Node<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> NULL;
            <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>child[left]) temp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>child[left];
            <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>child[right]) temp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>child[right];

            <span style="color:#66d9ef">if</span>(red(node)) <span style="color:#75715e">/// the node is red =&gt; just delete it
</span><span style="color:#75715e"></span>            {
                free(node);
                ok <span style="color:#f92672">=</span> true;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(red(temp)) <span style="color:#75715e">/// only child is red =&gt; replace with that red child and recolor black . so , black balance restored
</span><span style="color:#75715e"></span>            {
                temp<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK;
                free(node);
                ok <span style="color:#f92672">=</span> true;
            }

            <span style="color:#66d9ef">return</span> temp;
        }
        <span style="color:#66d9ef">else</span> <span style="color:#75715e">/// has 2 child =&gt; replace with inorder predecessor / successor and recurse for that
</span><span style="color:#75715e"></span>        {
            Node <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> getMax(node<span style="color:#f92672">-&gt;</span>child[left]); <span style="color:#75715e">/// inorder predecessor : maximum value in the left subtree
</span><span style="color:#75715e"></span>
            node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>data;
            data <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>data; <span style="color:#75715e">/// updating with predecessor data as this is the one to delete now
</span><span style="color:#75715e"></span>        }
    }


    <span style="color:#66d9ef">bool</span> dir <span style="color:#f92672">=</span> data <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>data;

    node<span style="color:#f92672">-&gt;</span>child[dir] <span style="color:#f92672">=</span> __delete(node<span style="color:#f92672">-&gt;</span>child[dir],data,ok); <span style="color:#75715e">/// recurse
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">return</span> ok <span style="color:#f92672">?</span> node : DELETE_FIX_UP(node,dir,ok);
}
</code></pre></div><p>Now , we have to write the magic function <strong><code>DELETE_FIX_UP</code></strong> .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">DELETE_FIX_UP</span>(Node <span style="color:#f92672">*</span>node,<span style="color:#66d9ef">bool</span> dir, <span style="color:#66d9ef">bool</span> <span style="color:#f92672">&amp;</span>ok)
{
    Node <span style="color:#f92672">*</span>parent <span style="color:#f92672">=</span> node; <span style="color:#75715e">/// saving for later red sibling fixing case
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>sibling <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir];

    <span style="color:#75715e">/// Red Sibling Case =&gt; Reduce to Black Sibling Case
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(red(sibling))
    {
        node <span style="color:#f92672">=</span> rotate(node,dir);
        sibling <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir];
    }

    <span style="color:#66d9ef">if</span>(sibling <span style="color:#f92672">!=</span> NULL)
    {
        <span style="color:#75715e">/// Black Sibling Case , Part 1 : Black Sibling with only black children
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>red(sibling<span style="color:#f92672">-&gt;</span>child[left]) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>red(sibling<span style="color:#f92672">-&gt;</span>child[right]))
        {
            <span style="color:#66d9ef">if</span>(red(parent)) ok <span style="color:#f92672">=</span> true; <span style="color:#75715e">/// will color it black and sibling subtree will not have imbalance
</span><span style="color:#75715e"></span>
            parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK; <span style="color:#75715e">/// if not ok , we proceed further
</span><span style="color:#75715e"></span>            sibling<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> RED;
        }
        <span style="color:#66d9ef">else</span> <span style="color:#75715e">/// Black Sibling Case , Part 2 : Black Sibling with not red children
</span><span style="color:#75715e"></span>        {

            <span style="color:#66d9ef">int</span> initcol_parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>color;
            <span style="color:#66d9ef">bool</span> isRedSiblingReduction <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>(node<span style="color:#f92672">==</span>parent);

            <span style="color:#66d9ef">if</span>(red(sibling<span style="color:#f92672">-&gt;</span>child[<span style="color:#f92672">!</span>dir])) <span style="color:#75715e">/// RR , LL
</span><span style="color:#75715e"></span>            {
                parent <span style="color:#f92672">=</span> rotate(parent,dir); <span style="color:#75715e">/// single rotation
</span><span style="color:#75715e"></span>            }
            <span style="color:#66d9ef">else</span>
            {
                parent <span style="color:#f92672">=</span> doubleRotate(parent,dir); <span style="color:#75715e">/// align and rotate
</span><span style="color:#75715e"></span>            }

            parent<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> initcol_parent; <span style="color:#75715e">/// color will be the same as initial parent
</span><span style="color:#75715e"></span>            parent<span style="color:#f92672">-&gt;</span>child[left]<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK;
            parent<span style="color:#f92672">-&gt;</span>child[right]<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> BLACK;

            <span style="color:#66d9ef">if</span>(isRedSiblingReduction)
            {
                node<span style="color:#f92672">-&gt;</span>child[dir] <span style="color:#f92672">=</span> parent; <span style="color:#75715e">/// fixing the child for proper bottom up fixing later
</span><span style="color:#75715e"></span>            }
            <span style="color:#66d9ef">else</span>
            {
                node <span style="color:#f92672">=</span> parent; <span style="color:#75715e">/// usual black case
</span><span style="color:#75715e"></span>            }

            ok <span style="color:#f92672">=</span> true;
        }
    }

    <span style="color:#66d9ef">return</span> node;
}

</code></pre></div><p>Ah , we are done finally ! It was not that awful , was it ?</p>
<blockquote>
<h1 id="optimization-and-conclusion"><strong>Optimization and Conclusion</strong><a href="#optimization-and-conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>If you have come this far down , let me tell you one more thing . The RBT we studied is the classical old RBT . There are other implementations of RBT which makes the code even more shorter and easier to write . Among these , one is <strong><code>Left Leaning Red Black Tree</code></strong> <strong>(LLRB)</strong> . It is nothing but the implementation of the <em>first modified BST</em> we saw . And about the implementation , we can also use a <strong><code>topdown approach</code></strong> , that is also easier to understand than the bottom up approach . If you do feel interested , check them out .</p>
<p>Congrats on reading this far : D If you have any problem , do let me know . And if you liked the writeup do let me know too !</p>
<blockquote>
<h1 id="reference"><strong>Reference</strong><a href="#reference" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
</blockquote>
<p>Ah! lot of them , I&rsquo;m going to mention as many as I can remember.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree?oldformat=true">https://en.wikipedia.org/wiki/Red%E2%80%93black_tree?oldformat=true</a></li>
<li><a href="https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf</a></li>
<li><a href="http://smile.ee.ncku.edu.tw/old/Links/MTable/Course/DataStructure/2-3,2-3-4&amp;red-blackTree_952.pdf">http://smile.ee.ncku.edu.tw/old/Links/MTable/Course/DataStructure/2-3,2-3-4&amp;red-blackTree_952.pdf</a></li>
<li><a href="https://stackoverflow.com/questions/15455042/can-anyone-explain-the-deletion-of-left-lean-red-black-tree-clearly">https://stackoverflow.com/questions/15455042/can-anyone-explain-the-deletion-of-left-lean-red-black-tree-clearly</a></li>
<li><a href="https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf</a></li>
<li><a href="https://stackoverflow.com/questions/364616/in-red-black-trees-is-top-down-deletion-faster-and-more-space-efficient-than-bot/8024168#8024168">https://stackoverflow.com/questions/364616/in-red-black-trees-is-top-down-deletion-faster-and-more-space-efficient-than-bot/8024168#8024168</a></li>
<li><a href="https://www.youtube.com/watch?v=DQdMYevEyE4">https://www.youtube.com/watch?v=DQdMYevEyE4</a></li>
<li><a href="https://eternallyconfuzzled.com/red-black-trees-c-the-most-common-balanced-binary-search-tree">https://eternallyconfuzzled.com/red-black-trees-c-the-most-common-balanced-binary-search-tree</a></li>
<li><a href="https://stackoverflow.com/questions/14119995/red-black-tree-top-down-deletion-algorithm?rq=1">https://stackoverflow.com/questions/14119995/red-black-tree-top-down-deletion-algorithm?rq=1</a></li>
<li><a href="https://stackoverflow.com/questions/13360369/deletion-in-left-leaning-red-black-trees">https://stackoverflow.com/questions/13360369/deletion-in-left-leaning-red-black-trees</a></li>
<li><a href="ftp://ftp.cs.princeton.edu/techreports/1985/006.pdf">ftp://ftp.cs.princeton.edu/techreports/1985/006.pdf</a></li>
<li><a href="https://sites.cs.ucsb.edu/~teo/cs130a.m15/rbd.pdf">https://sites.cs.ucsb.edu/~teo/cs130a.m15/rbd.pdf</a></li>
<li><a href="https://stackoverflow.com/questions/14119995/red-black-tree-top-down-deletion-algorithm">https://stackoverflow.com/questions/14119995/red-black-tree-top-down-deletion-algorithm</a></li>
<li><a href="https://iq.opengenus.org/red-black-tree-deletion/">https://iq.opengenus.org/red-black-tree-deletion/</a></li>
<li><a href="https://github.com/jeffrey-xiao/competitive-programming/blob/master/src/codebook/datastructures/RedBlackTree.java">https://github.com/jeffrey-xiao/competitive-programming/blob/master/src/codebook/datastructures/RedBlackTree.java</a></li>
<li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/an-introduction-to-binary-search-and-red-black-trees/">https://www.topcoder.com/community/competitive-programming/tutorials/an-introduction-to-binary-search-and-red-black-trees/</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/141834/how-is-a-java-reference-different-from-a-c-pointer">https://softwareengineering.stackexchange.com/questions/141834/how-is-a-java-reference-different-from-a-c-pointer</a></li>
<li><a href="https://www.programiz.com/dsa/red-black-tree">https://www.programiz.com/dsa/red-black-tree</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></li>
<li><a href="https://www.cs.princeton.edu/courses/archive/fall06/cos226/lectures/balanced.pdf">https://www.cs.princeton.edu/courses/archive/fall06/cos226/lectures/balanced.pdf</a></li>
<li><a href="https://www.cs.princeton.edu/courses/archive/spring19/cos226/lectures/33BalancedSearchTrees.pdf">https://www.cs.princeton.edu/courses/archive/spring19/cos226/lectures/33BalancedSearchTrees.pdf</a></li>
</ul>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="https://zarif98sjs.github.io/blog/blog/depthawarevideoframeinterpolation/">
                <span class="button__text">A Research Paper Synopsis : Depth Aware Video Frame Interpolation</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  


<script src="https://utteranc.es/client.js"
        repo="zarif98sjs/blog"
        issue-term="pathname"
        label="Utterances Comment Box"
        theme="github-dark-orange"
        crossorigin="anonymous"
        async>
</script>

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span> Md. Zarif Ul ALam © 2020 </span>
    
        
      </div>
  </div>
</footer>

<script src="https://zarif98sjs.github.io/blog/assets/main.js"></script>
<script src="https://zarif98sjs.github.io/blog/assets/prism.js"></script>





<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
</div>

</body>
</html>
