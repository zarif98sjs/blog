<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>combinatorics on zarif98sjs</title>
    <link>/tags/combinatorics/</link>
    <description>Recent content in combinatorics on zarif98sjs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/combinatorics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LightOj 1060 (nth Permutation)</title>
      <link>/blog/lightoj1060/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/lightoj1060/</guid>
      <description>Idea  DP
 First of all we check maximum number of permutations possible from the given string &amp;hellip; if it is &amp;lt; n than ans is impossible. Now we have to fix character at each position starting from msb position For fixing the character at any position initially we try to fix smallest character at that position if by placing that character number of permutation formed &amp;gt;= remaining required permutation than fix this charter at that position , and decrease the frequency of this character since this character is used at this position and move to next position , else if no of permutation formed by placing this character is less than the required remaining permutation than decrease remaining permutation by the number of permutation formed by placing this character at that position ( since this count times number of permutations comes in between current to final permutation ) and try to find next character for this position .</description>
    </item>
    
    <item>
      <title>LightOj 1005 (Rooks)</title>
      <link>/blog/lightoj1005/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/lightoj1005/</guid>
      <description>Idea 1   Put a rook in row 1 , so there are c ways (c columns) to do that [c * shomadhan(r-1,c-1,k-1)] and don&amp;rsquo;t put a rook in row 1 , so there are r-1 rows [shomadhan(r-1,c,k)] So , ans = c * shomadhan(r-1,c-1,k-1) + shomadhan(r-1,c,k)  Idea 2   take k row from n row (nCk) take k col from n col (nCk) how many ways k rook arrange among themselves (k!</description>
    </item>
    
  </channel>
</rss>