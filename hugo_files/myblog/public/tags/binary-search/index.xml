<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary search on zarif98sjs</title>
    <link>https://zarif98sjs.github.io/blog/tags/binary-search/</link>
    <description>Recent content in binary search on zarif98sjs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://zarif98sjs.github.io/blog/tags/binary-search/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LightOj 1127 (Funny Knapsack)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1127/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1127/</guid>
      <description>Idea  Meet In The Middle
 The idea is that you split the large set into two small sets, small enough for you to handle them using the standard algorithm you know, and then use the result from these two small sets to arrive at the required solution. Complexity : O(2^(n / 2) log (2^(n / 2))  /** Which of the favors of your Lord will you deny ?</description>
    </item>
    
    <item>
      <title>LightOj 1235 (Coin Change IV)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1235/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1235/</guid>
      <description>Idea  Meet In The Middle
 The idea is that you split the large set into two small sets, small enough for you to handle them using the standard algorithm you know, and then use the result from these two small sets to arrive at the required solution. Note that , if we made 2 same vectors of n elements , and calculated subset sum by taking 0/1 times of the elements, then that would get TLE .</description>
    </item>
    
    <item>
      <title>LightOj 1170 (Counting Perfect BST)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1170/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1170/</guid>
      <description>Idea  Binary Search / Catalan Number
 If there are n prefect power numbers in [a,b] , Answer is basically Catalan(n) Catalan(n) = (2n)! / (n! *(n+1)!)  Proof   Consider all possible binary search trees with each element at the root. If there are n nodes, then for each choice of root node, there are n â€“ 1 non-root nodes and these non-root nodes must be partitioned into those that are less than a chosen root and those that are greater than the chosen root.</description>
    </item>
    
    <item>
      <title>LightOj 1048 (Conquering Keokradong)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1048/</link>
      <pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1048/</guid>
      <description>Idea  Binary Search
 Say, each day you walk D distance. It is very easy to understand that, if you have enough large D, it is always possible to cover start to end with K stops. If you know D, you can check if it is possible to pass with K stops, if it is possible, may be it will also be possible for a lower D. On the other hand, if it is not yet possible, you must walk more time in a day.</description>
    </item>
    
    <item>
      <title>LightOj 1076 (Get the Containers)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1076/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1076/</guid>
      <description>Idea  Binary Search
 The target is to minimize the maximum capacity. Binary search over capacity &amp;lsquo;d&amp;rsquo; . If possible with capacity &amp;lsquo;d&amp;rsquo; , minimize and if not maximize using binary search .  /** Which of the favors of your Lord will you deny ? **/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define PLL pair&amp;lt;LL,LL&amp;gt; #define MP make_pair #define F first #define S second #define INF INT_MAX  #define ALL(x) (x).</description>
    </item>
    
    <item>
      <title>LightOj 1307 (Counting Triangles)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1307/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1307/</guid>
      <description>Idea  Binary Search
 For a triangle , the sum of any 2 side should be greater than the third side , which is to say the sum of the 2 shorter sides should be greater than the third side.
i.e a + b &amp;gt; c [where a&amp;lt;=b&amp;lt;=c]  /** Which of the favors of your Lord will you deny ? **/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define PLL pair&amp;lt;LL,LL&amp;gt; #define MP make_pair #define F first #define S second #define INF INT_MAX  #define ALL(x) (x).</description>
    </item>
    
    <item>
      <title>LightOj 1063 (Crossed Ladders)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1062/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1062/</guid>
      <description>Idea  Binary Search / Geometry
 Intersection of 2 line using cross product : http://bit.ly/line_intersection  /** Which of the favors of your Lord will you deny ? **/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define PLI pair&amp;lt;LL,int&amp;gt; #define LPII pair&amp;lt;LL, pair&amp;lt;int,int&amp;gt; &amp;gt; #define MP make_pair #define F first #define S second #define LINF LLONG_MAX  //#define EPS 1e-11 double INF=1e100; double EPS=1e-12; struct PT { double x,y; PT() {} PT(double x,double y) : x(x), y(y) {} PT(const PT &amp;amp;p) : x(p.</description>
    </item>
    
    <item>
      <title>LightOj 1088 (Points in Segments)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1088/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1088/</guid>
      <description>Idea  Binary Search
 Within time complexity only thing to do is binary search i.e use the lower_bound or the upper bound function to find the value of the index . lower_bound : points to the first number equals to the &amp;lsquo;num&amp;rsquo; or greater than the &amp;lsquo;num&amp;rsquo; upper_bound : points to the first number greater than the &amp;lsquo;num&amp;rsquo;  Critical Test Cases (Queries) :
6(present) 10(present) &amp;ndash;&amp;gt; r-l+1
5(absent) 10(present) &amp;ndash;&amp;gt; r-l+1</description>
    </item>
    
    <item>
      <title>LightOj 1056 (Olympics)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1056/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1056/</guid>
      <description>Idea  Binary Search / Geometry
 Total Perimeter = 2(s+a) = 2*(r*theta +a) = 2*(sqrt(a^2+b^2)*arctan(b/a) + a) So, we can Binary Search over a  /** Which of the favors of your Lord will you deny ? **/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define PLI pair&amp;lt;LL,int&amp;gt; #define LPII pair&amp;lt;LL, pair&amp;lt;int,int&amp;gt; &amp;gt; #define MP make_pair #define F first #define S second #define LINF LLONG_MAX  #define EPS 1e-11  int main() { int tc; scanf(&amp;#34;%d&amp;#34;,&amp;amp;tc); //freopen(&amp;#34;LightOj1056.</description>
    </item>
    
    <item>
      <title>LightOj 1043 (Triangle Partitioning)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1043/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1043/</guid>
      <description>Idea 1  Binary Search
 AB/AD = AC/AE = BC/DE So , AE = (ACAD)/AB
and , DE = (BCAD)/AB The area ratio of those two triangles can be calculated as a function of AD .
So, we can Binary Search over AD  Idea 2  Geometry
 AB/AD = AC/AE = BC/DE We know that , If two triangles are similar, then the ratio of the area of both triangles is proportional to the square of the ratio of their corresponding sides.</description>
    </item>
    
  </channel>
</rss>