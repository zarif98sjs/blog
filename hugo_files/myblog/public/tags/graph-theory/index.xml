<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>graph theory on zarif98sjs</title>
    <link>https://zarif98sjs.github.io/blog/tags/graph-theory/</link>
    <description>Recent content in graph theory on zarif98sjs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://zarif98sjs.github.io/blog/tags/graph-theory/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LightOj 1308 (Ant Network)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1308/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1308/</guid>
      <description>Idea  Articulation Point
Firstly there are 2 case :
 No Articulation point .
Then there must be at least 2 shaft such that if one fails , other works Articulation point is present in the graph.   No articulation point can have shaft in order to minimize the number of shafts. So , delete the articulation points and make a new Graph without them. Create a compressed SCC graph from that.</description>
    </item>
    
    <item>
      <title>LightOj 1291 (Real Life Traffic)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1291/</link>
      <pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1291/</guid>
      <description>Idea  Articulation Bridge
 Find the articulation bridges in the graph. If you remove the bridges, you will get several connected components. Think carefully, there are 2 types of components. The 1st one is the connected component which had more than one bridge, if you cut one bridge, it still can connect with other components through other bridge. The 2nd one is the component which had only one bridge, if you cut the bridge, it cannot connect with other components.</description>
    </item>
    
    <item>
      <title>LightOj 1300 (Odd Personality)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1300/</link>
      <pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1300/</guid>
      <description>Idea  Articulation Bridge
 Without bridges you can find two paths from a to b if they are connected. In any non-bicolorable graph there is a cycle of odd length.  /** Which of the favors of your Lord will you deny ? **/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define PLL pair&amp;lt;LL,LL&amp;gt; #define MP make_pair #define F first #define S second #define INF INT_MAX  #define ALL(x) (x).</description>
    </item>
    
    <item>
      <title>LightOj 1034 (Hit the Light Switches)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1034/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1034/</guid>
      <description>Idea  Topological Sort / Strongly Connected Component
 To visit all node we can simply touch minimum number of node by using topological sort.
OR just find the number of SCC  /**Which of the favors of your Lord will you deny ?**/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define MP make_pair #define F first #define S second  vector&amp;lt;int&amp;gt;adj[100010]; bool visited[10010]; stack&amp;lt;int&amp;gt;stk; void dfs1(int node) { visited[node]=true; for(int next:adj[node]) { if(visited[next]==false) dfs1(next); } stk.</description>
    </item>
    
    <item>
      <title>LightOj 1168 (Wishing Snake)</title>
      <link>https://zarif98sjs.github.io/blog/blog/lightoj1168/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://zarif98sjs.github.io/blog/blog/lightoj1168/</guid>
      <description>Idea  SCC
 Create DAG from SCC and just check if every node is reachable form the starting node (i.e node 0) by a single dfs  /**Which of the favors of your Lord will you deny ?**/ #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; #define LL long long #define PII pair&amp;lt;int,int&amp;gt; #define MP make_pair #define F first #define S second  int scc_num; vector&amp;lt;int&amp;gt;graph[100010]; vector&amp;lt;int&amp;gt;rev_graph[100010]; vector&amp;lt;int&amp;gt;new_graph[100010]; //vector&amp;lt;int&amp;gt;Map(1010,-1); //vector&amp;lt;int&amp;gt;SCCMap(1010,0);  int Map[1010]; int SCCMap[1010]; stack&amp;lt;int&amp;gt;stk; bool visited[1010]; bool flag=true; void forward_dfs(int node) { visited[node]=true; for(int next:graph[node]) { if(visited[next]==false) forward_dfs(next); } stk.</description>
    </item>
    
  </channel>
</rss>